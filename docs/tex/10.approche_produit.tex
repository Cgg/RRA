\part{Chapitre 10 : Approche Produit : « Modélisation de la qualité d’un produit logiciel »}

\section{Introduction}

La qualité peut être vue de deux manière :
\begin{itemize}
\item Par une \textbf{approche produit} : la qualité est une propriété intrinsèque du produit logiciel
\item Par une \textbf{approche processus} : la qualité a pour objectif de contrôler la manière et le cadre 	dans lequel le logiciel est développé : cela a pour conséquence de produire un logiciel de meilleur qualité.
\end{itemize}

\hfill\\

À la base on peut agir sur \textbf{deux facteurs} : les \textbf{exigences non fonctionnelles} (contraintes sur le développement), qui vont déterminer la fiabilité, la maintenabilité, l'efficacité, mais aussi sur les \textbf{exigences fonctionnelles} : qualité de l'analyse, choix de conception... Ce dernier facteur va déterminer la complétude, la clarté, et la cohérence du produit logiciel.

\hfill\\

La modélisation de la qualité se fait de deux points de vue : (Approche de McCall)
\begin{description}
\item[Qualité externe] : du point de vue du client – Le produit est conforme à ses attentes.
\item[Qualité interne] : du point  de vue du concepteur – La conception et la réalisation s'est fait dans le respect des exigences fonctionnelles et non fonctionnelles et développées dans des condition économiques acceptables.
\end{description}

Souvent, une bonne qualité interne amène une bonne qualité externe : si le produit est bien conçu et respecte les exigences du client, alors le produit va être conforme aux attentes du client. Des mesures et des contrôles sont utilisée pour mesurer l'écart entre les exigences client (fonc. et non fonc.). Une négociation entre les différentes partis (MOA, MOE) est envisagée si les contrôles et les mesures ne sont pas satisfaisante, donc si la qualité interne est trop basse, donc que la qualité externe fait défaut.

\hfill

Cette approche permet :
\begin{itemize}
\item En début de projet, de définir 	une politique de qualité
\item Par la suite, d'évaluer le niveau de qualité atteint
\end{itemize}

\hfill\\

Concept d'arbre de qualité. Il doit souvent être personnalisé pour être efficace. Cela se fait en fonction du type de produit, et du métier de l’entreprise.	 	 	 	

\section{2e partie : 1er niveau de décomposition : Les facteurs}

	 	 	 	
Pyramide de décomposition des niveaux de qualité :


Les usages du logiciels doivent être rassemblés selon 3 groupes :
\begin{description}
\item[Le fonctionnement : vue de l'utilisateur]
	\begin{itemize}
	\item Conformité – besoin clients
	\item Fiabilité – rendu du service souhaité avec la précision requise
	\item Efficacité
	\item Intégrité – Protection des données contre les attaques
	\item Facilité d'emploi
	\end{itemize}
\item[La transposition (portabilité, 	réutilisation, couplabilité...)]
	\begin{itemize}
	\item Portabilité : pouvoir changer le logiciel d'environnement matériel ou logiciel facilement
	\item Réutilisation : pouvoir	réutiliser du code pour un autre logiciel
	\item Couplabilité : pouvoir mettre ce logiciel en communication avec d'autre logiciels.
	\end{itemize}
\item[L'évolution]
	\begin{itemize}
	\item Maintenabilité : dépannage facile.
	\item Flexibilité : capacité à 	évoluer facilement
	\item Testabilité : capacité à pouvoir facilement tester le logiciel.
	\end{itemize}
\end{description}

\hfill\\
	 	 	 	
Certains facteurs sont en opposition (par exemple, si l'on veut un logiciel plus efficace, bien souvent, le code est plus compliqué, et donc la maintenabilité en prend un coup).

\hfill\\

En général, on classe le niveau d'exigence de A à D, avec D le plus faible et A le plus critique, et selon des domaines d'application (sûreté, économie, sécurité, environnement).\\

\textbf{Exemple : Niveau d'exigence B}

\begin{tabular}{|c|c|}
\hline
Sureté & Attente à la vie des personnes\\
\hline
Economie & Perte économiques\\
\hline
Sécurité & Service et informations critiques\\
\hline
Environnement & Nuisance de l'environnement récupérable\\
\hline
\end{tabular}

\hfill\\

Pour déterminer le niveau d'exigence, on utilise un processus en trois étapes :\\
On formule les besoins : première liste de facteurs. Puis on prend les plus importants, et on leurs associe un niveau d'exigence (de priorité). Enfin, on choisi les principales disposition d'assurance qualité et de contrôle qualité, selon les bonnes pratiques.\\
Cela débouche sur le Plan d'assurance qualité logiciel (PAQL).\\

Cela se fait avec le client, et devient en fait les clauses qualité dans le contrat. On a des facteurs, donc on se réfère au cours d'Aide à la Décision, pour faire le choix (en général, Aubry dit d'utiliser une moyenne pondérée, ou de regarder les contradictions entre les facteurs).

\section{Deuxième partie : 2e niveau de décomposition : les critères}

Il y a 23 propriétés d'un logiciel, pour lesquelles le génie logiciel et l'assurance qualité offrent un moyen de contrôle.

\begin{itemize}

\item Fonctionnement
	\begin{itemize}

	\item Facilité d'emploi
		\begin{description}	
		\item[Facilité d'apprentissage] : le logiciel est simple à prendre en main pour un nouvel utilisateur (aide en ligne)		
		\item[Facilité d'utilisation] : le logiciel précise clairement comment il doit être utilisé (et a de la doc).
		\item[Communicabilité] : le logiciel a une IHM pratique, aisée à comprendre (norme d'interface, étude d'ergonomie).
		\end{description}

	\item Intégrité
		\begin{description}	
		\item[Contrôle des accès] : On peut restreindre certaines 	fonctionnalité à certains types d'utilisateurs.			
		\item[Vérification des accès] : on peut suivre l'accès aux données (date de dernière modif, etc.).
		\end{description}

	\item Efficacité
		\begin{description}	
		\item[Efficacité de stockage] : le logiciel utilise le minimum de mémoire pour son exécution			
		\item[Efficacité d'exécution] : Le logiciel utilise un minimum de temps machine pour son exécution.
		\end{description}

	\item Conformité
		\begin{description}	
		\item[Traçabilité] : On peut tracer les modifications dans les données dans tout le logiciel.		
		\item[Complétude] : Le logiciel remplit la totalité des fonctions pour lequel il a été conçu.
		\end{description}

	\item Fiabilité
		\begin{description}	
		\item[Précision] : précision exigée dans le calcul (demande de vérification par un expert, analyse numérique).
		\item[Tolérance aux erreurs] : Le logiciel peut continuer à fonctionner après une erreur (traitement des exceptions, etc.)
		\item[Homogénéité] : Vocabulaire uniforme, etc., dans le but d'augmenter la prédictabilité (au niveau documentation, interface, etc.).
		\item[Simplicité] : les choix de réalisation sont faciles à comprendre.
		\item[Concision] : Il n'y a pas trop de code inutilement présent, trop de blabla dans les docs, etc.
		\end{description}

	\end{itemize}

\item Évolution
	\begin{itemize}

	\item Maintenabilité
		\begin{description}			
		\item[Auto-description] : le logiciel décrit son propre fonctionnement.		
		\item[Modularité] : on peut interchanger des blocs logiciels, ça fonctionne toujours.
		\item[Extensibilité] : on peut ajouter de fonctionnalités facilement, redimensionner la capacité de stockage, etc.
		\end{description}

	\item Testabilité
		\begin{description}	
		\item[Instrumentation] : On peut mesurer les temps d'exécution, les erreurs survenues, etc.
		\end{description}

	\item Flexibilité
		\begin{description}	
		\item[Indépendance matérielle] : on peut faire tourner le logiciel sur un grand nombre de matériel différents.
		\end{description}

	\end{itemize}	

\item Transposition
	\begin{itemize}

	\item Réutilisabilité
		\begin{description}	
		\item[Généralité] : Capacité à conserver le code en ajoutant plein de fonctionnalité, à rester ouvert au changement.
		\end{description}

	\item Portabilité	
		\begin{description}	
		\item[Indépendance matérielle, logicielle] : pas trop de dépendances à des bibliothèques externes, à un système d'exploitation.
		\end{description}

	\item Couplabilité
		\begin{description}	
		\item[Standardisation des communications] : Utilisation de 	 protocoles standards (HTTP, DBUS, CORBA, etc.).
		\item[Standardisation des données] : Utilisation de standards normalisés pour le stockage des données (SQL, XML, YML, STL, etc.).
		\end{description}

	\end{itemize}

\end{itemize}


\section{Troisième partie : 3e niveau de décomposition : les métriques}

Les métriques et indicateurs servent à mettre des chiffres derrière les critères, car \textit{« Sans mesure, pas de contrôle, sans contrôle, pas de qualité »}.\\
On utilise donc souvent une approche dite quantitative pour ce contrôler l’état du projet par rapport à ces objectifs.\\ 
On a donc quatre objectifs principaux pour la qualité :
\begin{enumerate}
\item Évaluer le niveau de qualité atteint
\item Répartir l’effort de test
\item Estimer l’effort de maintenance et de difficulté d’un transfert
\item Détecter les séquences à haut risque
\end{enumerate}

\hfill\\

Trois grandes approches de l’approche quantitative :
\begin{enumerate}
\item L’analyse statique : sans lancer le programme (détection de fautes de styles, comptage des commentaires, graphes d’appel, complexité cyclomatique,en gros ce que fait Kalistik). Exemple de métrique : nombre d’arc du graphe d’appel, nombre de noeuds, nombre de niveau, complexité hierarchique (nombre de composants / nombre de niveaux).
\item L’analyse dynamique : pendant que le programme tourne (profiling du code, détection de fuites de mémoire, en gros, ce que fait Valgrind). On prend aussi en compte dans cette approche l’analyse de modèle de fiabilité (mean time to failure, par exemple).
\item L’analyse formelle : beaucoup plus de maths, calcul manuel de deadlines pour le temps réel, par exemple (beaucoup plus cher, et à réserver aux systèmes critiques).
\end{enumerate}

\hfill\\

On peut faire trois types de mesures :
\begin{enumerate}
\item Des mesures absolues
\item Des mesures relatives
\item Des mesures booléennes
\end{enumerate}

On définit des bornes inférieures et supérieures à ne pas dépasser pour les mesures absolues et relatives.\\

Quatre sources de mesures pour l’approche quantitative :
\begin{enumerate}
\item Dossier de spécif, de conception préliminaire, etc.
\item Jeux de tests
\item Mesure de performances, d’exploitation
\item Règles, normes de production
\end{enumerate}

\hfill\\

On a exactement 11 facteurs, 23 critères, et 176 métriques au total, normalisées dans l’intervalle [0; 1], la plupart se calculant lors du codage et de la conception.

\hfill\\

Un autre élément à considérer : la couverture des tests.\\
On définit les objets à tester, et on calcule le ratio nombre d’objets testés (et avec les tests qui passent) / nombre d’objets à tester. Quand on est à 1, on a atteint notre objectif.

\hfill\\

On teste tout en trois passes :
\begin{enumerate}
\item Niveau mesure : comparaison à des valeurs seuils
\item Niveau critères : classification du composant selon la valeur chiffrée, et selon une association mesure-critère qui a été définie et qui est propre à chaque critère et mesure.
\item Bilan : Classification du composant selon l’ensemble des critères associés.
\end{enumerate}


On fait ensuite en graphe de Kiviat (spider chart : comme ci-dessous) :\\
avec des seuil : valeur minimum acceptable, valeur maximum acceptable. Quand un composant respecte toutes les normes, alors le polygone qui lui est associé est à l’intérieur du polygone de référence.
\hfill\\
Il ne faut pas oublier qu’on est en démarche produit. On pourrait donc résumer l’approche retenue dans le schéma ci-dessous :\\


\section{Conclusion}

Les méthodes présentés sont assez vieilles, mais elle marchent. On doit cependant les remettre au goût du jour avec les nouvelles technologies (comme l’objet, qui a ses propres métriques).
On peut avoir des nouveaux facteurs aussi, par exemple la disponibilité d’un serveur critique, la robustesse (on essaie de faire crasher le système, et on évalue sa capacité à tenir face aux attaques, voulues ou non).\\

La qualité logicielle est modélisable, mesurable.
